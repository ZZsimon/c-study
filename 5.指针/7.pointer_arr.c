# include <stdio.h>

int main(void)
{
    // a既然是一个指针常量，也就是a代表着内存中的一个空间。
    // 那么，这个空间多大呢？
    int a[5] = {11,22,33,44,55};
    double b[5] = {1.1,2.2,3.3,4.4,5.5};

    int a1; // 4
    double b1; // 8
    int * a11; // 8
    double * b11; // 8

    printf("a的空间大小：%lu字节\n", sizeof(a));
    printf("b的空间大小：%lu字节\n", sizeof(b));
    printf("a1的空间大小：%lu字节\n", sizeof(a1));
    printf("b1的空间大小：%lu字节\n", sizeof(b1));
    printf("a11的空间大小：%lu字节\n", sizeof(a11));
    printf("b11的空间大小：%lu字节\n", sizeof(b11));

    // 通过上面的测试可以得知：
        // 1.操作系统给【普通变量】分配的内存空间根据【它前面的数据类型】来决定
        // 2.给【指针变量】分配的内存空间是【固定的】，因为这个空间【存放的数据是一个内存地址】。
            // 计算机中的内存地址这种数据大小是固定的，这种数据的大小是由硬件来决定的！
            // 普通的变量中存放的数据都只是一些自定义的字符或者数字！！！
        // 3.给数组变量分配的内存大小是由数组的数据类型和元素个数决定的。

    // ---------------- 这里又出现了一个问题
    // 前面验证了a变量代表着的是内存中的一块空间，而且存放的是一个地址，也就是说a是一个指针变量
    // 那么，输出a大小应该是和其他指针变量一样的结果，但是这里输出的却是数组占据的大小！！!

    // 这里，我们只能这么理解了，int a[5] 这个语句的作用：
        // 1.a确实关联了内存中的一个空间，这个空间中确实存放了第一个元素的地址
        // 2.a还和 那一段连续的内存空间有关联，具体怎么关联的不知道！！！！
        //      sizeof(a)的时候，操作系统会通过前面的关联性获取到那一段连续的内存空间大小！！！

    return 0;
}