# include <stdio.h>
# include <mm_malloc.h>

/**
 * 【指针类型变量的本质】
 *      1.指针变量占了几个字节
 *      2.保存数据是一个内存地址（只有一个！）
 *      3.但是操作系统可以根据指针变量的类型将指针变量和具体多个内存地址做关联
 * 
 */
int main(void)
{
    int i = 5; // 分配了4个字节内存 静态分配

    int * p;
    /**
     * 变量占据的字节是多大？换句话说就是系统为变量分配的内存到底是多大？
     *  这个是和变量的数据类型有关系：int就是4个字节、double就是8个字节。
     * 
     *  如果变量的类型是一个指针的话，那就是4个字节（不管是什么类型的指针）。
     *  但是不同的指针可以存放的地址是不一样的！
     *  如果是int类型的指针，存放的地址对应的内存空间只能存放int类型的数据。
     * 
     *  所以，p这个指针变量只能接收内存地址，并且这个内存地址对应的内存空间只能存放int类型的数据
    */

    int m = 5; // 分配了4个字节内存 静态分配

    int * n = &m;
    /**
     * m变量占据了4个字节大小，也就是说有4个内存地址（每一个字节都有一个内存地址）
     * &m 这个操作是将【m占据的字节中的第一个字节的内存地址】获取到了
     * 然后，第一个字节的内存地址放到了n这个变量的空间中。
     *  注：每一个内存地址大小都是4个字节，所以【m占据的字节中的第一个字节的内存地址】的大小就是4个字节
     * n这个变量本身占据了4个字节大小，所以n刚刚好可以存放【m占据的字节中的第一个字节的内存地址】
     * 
     * 也就是说，n中只存放了一个字节的内存地址，虽然只有这一个内存地址，但是我们可以知道这个内存地址是属于哪一个变量的
     * 就比如说，虽然n只存放了m的第一个字节的内存地址。
     * 【很重要：但是通过*n，我们可以获取到m变量占据的所有字节中保存的数据！这个是因为n的数据类型是一个指针导致的！】
     * 举个例子：   
     *  double j = 5;
     *  double * k = &j;
     *  j占据8个字节（有8个内存地址），但是k中保存的内存地址只是那8个中的第一个。
     *  但是k代表着那8个字节
     * 
    */

    return 0;
}
