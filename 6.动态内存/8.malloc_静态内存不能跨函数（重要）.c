# include <stdio.h>
# include <mm_malloc.h>

void f();


/**
 * 【静态内存不能跨函数】
 *        静态内存会被释放，释放后，当前程序不能再使用这块内存！！！
 * 
*/
int main(void)
{
    int * p;

    f(&p); 

    // f函数执行完毕后，i变量虽然不再被当前程序控制
    // 但是i变量对应的内存空间中的值并没有被销毁
    // 所以f函数执行完毕后， *p拿到的是是i变量对应的内存空间中的值（可以拿到这个值。）
    // -------------- 分割线 ------------
    
    // 但是这样写是有问题的，因为*p拿到的是是i变量对应的内存空间中的值
    // 但是！！！ f函数执行完毕后，i变量对应的内存空间已经不在被当前程序控制，所以虽然可以拿到5这个值，但是这是不符合计算机内存管理的规则
    // 也就是说，当输出 *p 的时候，它的值并不一定是5（如果输出前其他程序比如qq正好用到了内存中本来给i变量分配的内存，那么输出的时候可能就不是5了）
    // 总结：当前程序不能使用没有被当前程序控制的内存空间！
    printf("%d\n",*p);

    return 0;
}

void f(int ** q)
{
    int i = 5;

    *q = &i; // *q只能接收内存地址。

};
